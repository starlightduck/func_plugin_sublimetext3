{
    "int": {"docs" : "<strong>Documentation for int</strong><p>Is the type of 257-bit signed integers. By default, overflow checks are enabled and lead to integer overflow exception.</p>","example_use" : "int"},"cell": {"docs" : "<strong>Documentation for cell</strong><p>Is the type of TVM cells. All persistent data in TON Blockchain is stored in trees of cells. Every cell has up to 1023 bits of arbitrary data in it and up to 4 references to other cells. Cells play a role of memory in stack-based TVM. </p>","example_use" : "cell"},"slice": {"docs" : "<strong>Documentation for slice</strong><p>Is the type of cell slices. Cell can be transformed to a slice, and then the data bits and references to other cells from the cell can be obtained by loading them from the slice.</p>","example_use" : "slice"},"builder": {"docs" : "<strong>Documentation for builder</strong><p>Is the type of cell builders. Data bits and references to other cells can be stored into a builder, and then the builder can be finalized to a new cell.</p>","example_use" : "builder"},"tuple": {"docs" : "<strong>Documentation for tuple</strong><p>Is the type of TVM tuples. Tuple is an ordered collection of up to 255 components, having arbitrary value types, possibly distinct.</p>","example_use" : "tuple"},"cont": {"docs" : "<strong>Documentation for cont</strong><p>Is the type of TVM continuations. Continuations are used for controlling the flow of TVM program execution. It is rather a low-level object from the perspective of FunC, although somewhat paradoxically quite general. </p>","example_use" : "cont"},"cons": {"docs": "<strong>Documentation for cons</strong><p>Adds an element to the beginning of lisp-style list.\n</p>"}, "uncons": {"docs": "<strong>Documentation for uncons</strong><p>Extracts the head and the tail of lisp-style list.\n</p>"}, "list_next": {"docs": "<strong>Documentation for list_next</strong><p>Extracts the tail and the head of lisp-style list. Can be used as (non-)modifying method.\n</p>"}, "car": {"docs": "<strong>Documentation for car</strong><p>Returns the head of lisp-style list.\n</p>"}, "cdr": {"docs": "<strong>Documentation for cdr</strong><p>Returns the tail of lisp-style list.\n</p>"}, "empty_tuple": {"docs": "<strong>Documentation for empty_tuple</strong><p>Creates 0-element tuple.\n</p>"}, "tpush": {"docs": "<strong>Documentation for tpush</strong><p>Appends a value x to a Tuple t = (x1, ..., xn), but only if the resulting Tuple t' = (x1, ..., xn, x) is of length at most 255. Otherwise throws a type check exception.\n</p>"}, "single": {"docs": "<strong>Documentation for single</strong><p>Creates a singleton, i.e. a tuple of length one.\n</p>"}, "unsingle": {"docs": "<strong>Documentation for unsingle</strong><p>Unpacks a singleton.\n</p>"}, "pair": {"docs": "<strong>Documentation for pair</strong><p>Creates a pair.\n</p>"}, "unpair": {"docs": "<strong>Documentation for unpair</strong><p>Unpacks a pair.\n</p>"}, "triple": {"docs": "<strong>Documentation for triple</strong><p>Creates a triple.\n</p>"}, "untriple": {"docs": "<strong>Documentation for untriple</strong><p>Unpacks a triple.\n</p>"}, "tuple4": {"docs": "<strong>Documentation for tuple4</strong><p>Creates 4-element tuple.\n</p>"}, "untuple4": {"docs": "<strong>Documentation for untuple4</strong><p>Unpack 4-element tuple.\n</p>"}, "first": {"docs": "<strong>Documentation for first</strong><p>Returns the first element of a tuple.\n</p>"}, "second": {"docs": "<strong>Documentation for second</strong><p>Returns the second element of a tuple.\n</p>"}, "third": {"docs": "<strong>Documentation for third</strong><p>Returns the third element of a tuple.\n</p>"}, "fourth": {"docs": "<strong>Documentation for fourth</strong><p>Returns the fourth element of a tuple.\n</p>"}, "pair_first": {"docs": "<strong>Documentation for pair_first</strong><p>Returns the first element of a pair.\n</p>"}, "pair_second": {"docs": "<strong>Documentation for pair_second</strong><p>Returns the second element of a pair.\n</p>"}, "triple_first": {"docs": "<strong>Documentation for triple_first</strong><p>Returns the first element of a triple.\n</p>"}, "triple_second": {"docs": "<strong>Documentation for triple_second</strong><p>Returns the second element of a triple.\n</p>"}, "triple_third": {"docs": "<strong>Documentation for triple_third</strong><p>Returns the third element of a triple.\n</p>"}, "now": {"docs": "<strong>Documentation for now</strong><p>Returns the current Unix time as an Integer\n</p>"}, "my_address": {"docs": "<strong>Documentation for my_address</strong><p>Returns the internal address of the current smart contract as a Slice with a MsgAddressInt. If necessary, it can be parsed further using primitives such as parse_std_addr.\n</p>"}, "get_balance": {"docs": "<strong>Documentation for get_balance</strong><p>Returns the remaining balance of the smart contract as a tuple consisting of an int (the remaining balance in nanotoncoins) and a cell (a dictionary with 32-bit keys representing the balance of \u0432\u0402\u045aextra currencies\u0432\u0402\u045c). Note that RAW primitives such as send_raw_message do not update this field.\n</p>"}, "cur_lt": {"docs": "<strong>Documentation for cur_lt</strong><p>Returns the logical time of the current transaction.\n</p>"}, "block_lt": {"docs": "<strong>Documentation for block_lt</strong><p>Returns the starting logical time of the current block.\n</p>"}, "config_param": {"docs": "<strong>Documentation for config_param</strong><p>Returns the value of the global configuration parameter with integer index i as a cell or null value.\n</p>"}, "cell_hash": {"docs": "<strong>Documentation for cell_hash</strong><p>Computes the representation hash of a cell c and returns it as a 256-bit unsigned integer x. Useful for signing and checking signatures of arbitrary entities represented by a tree of cells.\n</p>"}, "slice_hash": {"docs": "<strong>Documentation for slice_hash</strong><p>Computes the hash of a slice s and returns it as a 256-bit unsigned integer x. The result is the same as if an ordinary cell containing only data and references from s had been created and its hash computed by cell_hash.\n</p>"}, "string_hash": {"docs": "<strong>Documentation for string_hash</strong><p>Computes sha256 of the data bits of slice s. If the bit length of s is not divisible by eight, throws a cell underflow exception. The hash value is returned as a 256-bit unsigned integer x.\n</p>"}, "check_signature": {"docs": "<strong>Documentation for check_signature</strong><p>Checks the Ed25519-signature of a hash (a 256-bit unsigned integer, usually computed as the hash of some data) using public_key (also represented by a 256-bit unsigned integer). The signature must contain at least 512 data bits; only the first 512 bits are used. The result is \u0432\u20ac\u20191 if the signature is valid, 0 otherwise. Note that CHKSIGNU creates a 256-bit slice with the hash and calls CHKSIGNS. That is, if hash is computed as the hash of some data, these data are hashed twice, the second hashing occurring inside CHKSIGNS.\n</p>"}, "check_data_signature": {"docs": "<strong>Documentation for check_data_signature</strong><p>Checks whether signature is a valid Ed25519-signature of the data portion of slice data using public_key, similarly to check_signature. If the bit length of data is not divisible by eight, throws a cell underflow exception. The verification of Ed25519 signatures is the standard one, with sha256 used to reduce data to the 256-bit number that is actually signed.\n</p>"}, "compute_data_size?": {"docs": "<strong>Documentation for compute_data_size?</strong><p>Returns (x, y, z, -1) or (null, null, null, 0). Recursively computes the count of distinct cells x, data bits y, and cell references z in the DAG rooted at cell c, effectively returning the total storage used by this DAG taking into account the identification of equal cells. The values of x, y, and z are computed by a depth-first traversal of this DAG, with a hash table of visited cell hashes used to prevent visits of already-visited cells. The total count of visited cells x cannot exceed non-negative max_cells; otherwise the computation is aborted before visiting the (max_cells + 1)-st cell and a zero flag is returned to indicate failure. If c is null, returns x = y = z = 0.\n</p>"}, "slice_compute_data_size?": {"docs": "<strong>Documentation for slice_compute_data_size?</strong><p>Similar to compute_data_size?, but accepting a slice s instead of a cell. The returned value of x does not take into account the cell that contains the slice s itself; however, the data bits and the cell references of s are accounted for in y and z.\n</p>"}, "compute_data_size": {"docs": "<strong>Documentation for compute_data_size</strong><p>A non-quiet version of compute_data_size? that throws a cell overflow exception (8) on failure.\n</p>"}, "slice_compute_data_size": {"docs": "<strong>Documentation for slice_compute_data_size</strong><p>A non-quiet version of slice_compute_data_size? that throws a cell overflow exception (8) on failure.\n</p>"}, "get_data": {"docs": "<strong>Documentation for get_data</strong><p>Returns the persistent contract storage cell. It can be parsed or modified with slice and builder primitives later.\n</p>"}, "set_data": {"docs": "<strong>Documentation for set_data</strong><p>Sets cell c as persistent contract data. You can update persistent contract storage with this primitive.\n</p>"}, "get_c3": {"docs": "<strong>Documentation for get_c3</strong><p>Usually c3 has a continuation initialized by the whole code of the contract. It is used for function calls. The primitive returns the current value of c3.\n</p>"}, "set_c3": {"docs": "<strong>Documentation for set_c3</strong><p>Updates the current value of c3. Usually it is used for updating smartcontract code in run-time. Note that after execution of this primitive the current code (and the stack of recursive function calls) won't change, but any other function call will use a function from the new code.\n</p>"}, "bless": {"docs": "<strong>Documentation for bless</strong><p>Transforms a slice s into a simple ordinary continuation c, with c.code = s and an empty stack and savelist.\n</p>"}, "accept_message": {"docs": "<strong>Documentation for accept_message</strong><p>Sets current gas limit gl to its maximal allowed value gm, and resets the gas credit gc to zero, decreasing the value of gr by gc in the process. In other words, the current smart contract agrees to buy some gas to finish the current transaction. This action is required to process external messages, which bring no value (hence no gas) with themselves.\n</p>"}, "set_gas_limit": {"docs": "<strong>Documentation for set_gas_limit</strong><p>Sets current gas limit gl to the minimum of limit and gm, and resets the gas credit gc to zero. If the gas consumed so far (including the present instruction) exceeds the resulting value of gl, an (unhandled) out of gas exception is thrown before setting new gas limits. Notice that set_gas_limit with an argument limit \u0432\u2030\u0490 2^63 \u0432\u20ac\u2019 1 is equivalent to accept_message.\n</p>"}, "commit": {"docs": "<strong>Documentation for commit</strong><p>Commits the current state of registers c4 (\u0432\u0402\u045apersistent data\u0432\u0402\u045c) and c5 (\u0432\u0402\u045aactions\u0432\u0402\u045c) so that the current execution is considered \u0432\u0402\u045asuccessful\u0432\u0402\u045c with the saved values even if an exception is thrown later.\n</p>"}, "buy_gas": {"docs": "<strong>Documentation for buy_gas</strong><p>Computes the amount of gas that can be bought for gram nanotoncoins, and sets gl accordingly in the same way as set_gas_limit.\n</p>"}, "raw_reserve": {"docs": "<strong>Documentation for raw_reserve</strong><p>Creates an output action which would reserve exactly amount nanotoncoins (if mode = 0), at most amount nanotoncoins (if y = 2), or all but amount nanotoncoins (if mode = 1 or mode = 3), from the remaining balance of the account. It is roughly equivalent to creating an outbound message carrying amount nanotoncoins (or b \u0432\u20ac\u2019 amount nanotoncoins, where b is the remaining balance) to oneself, so that the subsequent output actions would not be able to spend more money than the remainder. Bit +2 in mode means that the external action does not fail if the specified amount cannot be reserved; instead, all remaining balance is reserved. Bit +8 in mode means amount <- -amount before performing any further actions. Bit +4 in mode means that amount is increased by the original balance of the current account (before the compute phase), including all extra currencies, before performing any other checks and actions. Currently amount must be a non-negative integer, and mode must be in the range 0..15.\n</p>"}, "raw_reserve_extra": {"docs": "<strong>Documentation for raw_reserve_extra</strong><p>Similar to raw_reserve, but also accepts a dictionary extra_amount (represented by a cell or null) with extra currencies. In this way currencies other than TonCoin can be reserved.\n</p>"}, "send_raw_message": {"docs": "<strong>Documentation for send_raw_message</strong><p>Sends a raw message contained in msg, which should contain a correctly serialized object Message X, with the only exception that the source address is allowed to have dummy value addr_none (to be automatically replaced with the current smartcontract address), and ihr_fee, fwd_fee, created_lt and created_at fields can have arbitrary values (to be rewritten with correct values during the action phase of the current transaction). Integer parameter mode contains the flags. Currently mode = 0 is used for ordinary messages; mode = 128 is used for messages that are to carry all the remaining balance of the current smart contract (instead of the value originally indicated in the message); mode = 64 is used for messages that carry all the remaining value of the inbound message in addition to the value initially indicated in the new message (if bit 0 is not set, the gas fees are deducted from this amount); mode' = mode + 1 means that the sender wants to pay transfer fees separately; mode' = mode + 2 means that any errors arising while processing this message during the action phase should be ignored. Finally, mode' = mode + 32 means that the current account must be destroyed if its resulting balance is zero. This flag is usually employed together with +128.\n</p>"}, "set_code": {"docs": "<strong>Documentation for set_code</strong><p>Creates an output action that would change this smart contract code to that given by cell new_code. Notice that this change will take effect only after the successful termination of the current run of the smart contract (cf. set_c3).\n</p>"}, "random": {"docs": "<strong>Documentation for random</strong><p>Generates a new pseudo-random unsigned 256-bit integer x. The algorithm is as follows: if r is the old value of the random seed, considered as a 32-byte array (by constructing the big-endian representation of an unsigned 256-bit integer), then its sha512(r) is computed; the first 32 bytes of this hash are stored as the new value r' of the random seed, and the remaining 32 bytes are returned as the next random value x.\n</p>"}, "rand": {"docs": "<strong>Documentation for rand</strong><p>Generates a new pseudo-random integer z in the range 0..range\u0432\u20ac\u20191 (or range..\u0432\u20ac\u20191, if range < 0). More precisely, an unsigned random value x is generated as in random; then z := x * range / 2^256 is computed.\n</p>"}, "get_seed": {"docs": "<strong>Documentation for get_seed</strong><p>Returns the current random seed as an unsigned 256-bit Integer.\n</p>"}, "set_seed": {"docs": "<strong>Documentation for set_seed</strong><p>Sets the random seed to unsigned 256-bit seed.\n</p>"}, "randomize": {"docs": "<strong>Documentation for randomize</strong><p>Mixes unsigned 256-bit integer x into the random seed r by setting the random seed to sha256 of the concatenation of two 32-byte strings: the first with the big-endian representation of the old seed r, and the second with the big-endian representation of x.\n</p>"}, "randomize_lt": {"docs": "<strong>Documentation for randomize_lt</strong><p>Equivalent to randomize(cur_lt());.\n</p>"}, "load_msg_addr": {"docs": "<strong>Documentation for load_msg_addr</strong><p>Loads from slice s the only prefix that is a valid MsgAddress, and returns both this prefix s' and the remainder s'' of s as slices.\n</p>"}, "parse_addr": {"docs": "<strong>Documentation for parse_addr</strong><p>Decomposes slice s containing a valid MsgAddress into a tuple t with separate fields of this MsgAddress. If s is not a valid MsgAddress, a cell deserialization exception is thrown.\n</p>"}, "parse_std_addr": {"docs": "<strong>Documentation for parse_std_addr</strong><p>Parses slice s containing a valid MsgAddressInt (usually a msg_addr_std), applies rewriting from the anycast (if present) to the same-length prefix of the address, and returns both the workchain and the 256-bit address as integers. If the address is not 256-bit, or if s is not a valid serialization of MsgAddressInt, throws a cell deserialization exception.\n</p>"}, "parse_var_addr": {"docs": "<strong>Documentation for parse_var_addr</strong><p>A variant of parse_std_addr that returns the (rewritten) address as a slice s, even if it is not exactly 256 bit long (represented by a msg_addr_var).\n</p>"}, "dump_stack": {"docs": "<strong>Documentation for dump_stack</strong><p>Dumps the stack (at most the top 255 values) and shows the total stack depth.\n</p>"}, "begin_parse": {"docs": "<strong>Documentation for begin_parse</strong><p>Converts a cell into a slice. Notice that c must be either an ordinary cell, or an exotic cell (see TVM.pdf, 3.1.2) which is automatically loaded to yield an ordinary cell c', converted into a slice afterwards.\n</p>"}, "end_parse": {"docs": "<strong>Documentation for end_parse</strong><p>Checks if s is empty. If not, throws an exception.\n</p>"}, "load_ref": {"docs": "<strong>Documentation for load_ref</strong><p>Loads the first reference from the slice.\n</p>"}, "preload_ref": {"docs": "<strong>Documentation for preload_ref</strong><p>Preloads the first reference from the slice.\n</p>"}, "load_int": {"docs": "<strong>Documentation for load_int</strong><p>Loads a signed len-bit integer from a slice.\n</p>"}, "load_uint": {"docs": "<strong>Documentation for load_uint</strong><p>Loads an unsigned len-bit integer from a slice.\n</p>"}, "preload_int": {"docs": "<strong>Documentation for preload_int</strong><p>Preloads a signed len-bit integer from a slice.\n</p>"}, "preload_uint": {"docs": "<strong>Documentation for preload_uint</strong><p>Preloads an unsigned len-bit integer from a slice.\n</p>"}, "load_bits": {"docs": "<strong>Documentation for load_bits</strong><p>Loads the first 0 \u0432\u2030\u00a4 len \u0432\u2030\u00a4 1023 bits from slice s into a separate slice s''.\n</p>"}, "preload_bits": {"docs": "<strong>Documentation for preload_bits</strong><p>Preloads the first 0 \u0432\u2030\u00a4 len \u0432\u2030\u00a4 1023 bits from slice s into a separate slice s''.\n</p>"}, "load_grams": {"docs": "<strong>Documentation for load_grams</strong><p>Loads serialized amount of TonCoins (any unsigned integer up to 2^128 - 1).\n</p>"}, "skip_bits": {"docs": "<strong>Documentation for skip_bits</strong><p>Returns all but the first 0 \u0432\u2030\u00a4 len \u0432\u2030\u00a4 1023 bits of s.\n</p>"}, "first_bits": {"docs": "<strong>Documentation for first_bits</strong><p>Returns the first 0 \u0432\u2030\u00a4 len \u0432\u2030\u00a4 1023 bits of s.\n</p>"}, "skip_last_bits": {"docs": "<strong>Documentation for skip_last_bits</strong><p>Returns all but the last 0 \u0432\u2030\u00a4 len \u0432\u2030\u00a4 1023 bits of s.\n</p>"}, "slice_last": {"docs": "<strong>Documentation for slice_last</strong><p>Returns the last 0 \u0432\u2030\u00a4 len \u0432\u2030\u00a4 1023 bits of s.\n</p>"}, "load_dict": {"docs": "<strong>Documentation for load_dict</strong><p>Loads a dictionary D from slice s. May be applied to dictionaries or to values of arbitrary Maybe ^Y types (returns null if nothing constructor is used).\n</p>"}, "preload_dict": {"docs": "<strong>Documentation for preload_dict</strong><p>Preloads a dictionary D from slice s.\n</p>"}, "skip_dict": {"docs": "<strong>Documentation for skip_dict</strong><p>Loads a dictionary as load_dict, but returns only the remainder of the slice.\n</p>"}, "slice_refs": {"docs": "<strong>Documentation for slice_refs</strong><p>Returns the number of references in slice s.\n</p>"}, "slice_bits": {"docs": "<strong>Documentation for slice_bits</strong><p>Returns the number of data bits in slice s.\n</p>"}, "slice_bits_refs": {"docs": "<strong>Documentation for slice_bits_refs</strong><p>Returns both the number of data bits and the number of references in s.\n</p>"}, "slice_empty?": {"docs": "<strong>Documentation for slice_empty?</strong><p>Checks whether a slice s is empty (i.e., contains no bits of data and no cell references).\n</p>"}, "slice_data_empty?": {"docs": "<strong>Documentation for slice_data_empty?</strong><p>Checks whether slice s has no bits of data.\n</p>"}, "slice_refs_empty?": {"docs": "<strong>Documentation for slice_refs_empty?</strong><p>Checks whether slice s has no references.\n</p>"}, "slice_depth": {"docs": "<strong>Documentation for slice_depth</strong><p>Returns the depth of slice s. If s has no references, then returns 0; otherwise the returned value is one plus the maximum of depths of cells referred to from s.\n</p>"}, "begin_cell": {"docs": "<strong>Documentation for begin_cell</strong><p>Creates a new empty builder.\n</p>"}, "end_cell": {"docs": "<strong>Documentation for end_cell</strong><p>Converts a builder into an ordinary cell.\n</p>"}, "store_ref": {"docs": "<strong>Documentation for store_ref</strong><p>Stores a reference to cell c into builder b.\n</p>"}, "store_uint": {"docs": "<strong>Documentation for store_uint</strong><p>Stores an unsigned l-bit integer x into b for 0 \u0432\u2030\u00a4 l \u0432\u2030\u00a4 256.\n</p>"}, "store_int": {"docs": "<strong>Documentation for store_int</strong><p>Stores a signed l-bit integer x into b for 0 \u0432\u2030\u00a4 l \u0432\u2030\u00a4 257.\n</p>"}, "store_slice": {"docs": "<strong>Documentation for store_slice</strong><p>Stores slice s into builder b.\n</p>"}, "store_grams": {"docs": "<strong>Documentation for store_grams</strong><p>Stores (serializes) an integer x in the range 0..2^128 \u0432\u20ac\u2019 1 into builder b. The serialization of x consists of a 4-bit unsigned big-endian integer l, which is the smallest integer l \u0432\u2030\u0490 0, such that x < 2^8l, followed by an 8l-bit unsigned big-endian representation of x. If x does not belong to the supported range, a range check exception is thrown.<p>It is the usual way to store amounts of TonCoins.</p>\n</p>"}, "store_dict": {"docs": "<strong>Documentation for store_dict</strong><p>Stores dictionary D represented by cell c or null into builder b. In other words, stores a 1-bit and a reference to c if c is not null and 0-bit otherwise.\n</p>"}, "store_maybe_ref": {"docs": "<strong>Documentation for store_maybe_ref</strong><p>Equivalent to store_dict.\n</p>"}, "builder_refs": {"docs": "<strong>Documentation for builder_refs</strong><p>Returns the number of cell references already stored in builder b.\n</p>"}, "builder_bits": {"docs": "<strong>Documentation for builder_bits</strong><p>Returns the number of data bits already stored in builder b.\n</p>"}, "builder_depth": {"docs": "<strong>Documentation for builder_depth</strong><p>Returns the depth of builder b. If no cell references are stored in b, then returns 0; otherwise the returned value is one plus the maximum of depths of cells referred to from b.\n</p>"}, "cell_depth": {"docs": "<strong>Documentation for cell_depth</strong><p>Returns the depth of cell c. If c has no references, then return 0; otherwise the returned value is one plus the maximum of depths of cells referred to from c. If c is a null instead of a cell, returns zero.\n</p>"}, "cell_null?": {"docs": "<strong>Documentation for cell_null?</strong><p>Checks whether c is a null. Usually a null-cell represents an empty dictionary. FunC also has polymorphic null? built-in, see built-ins.\n</p>"}, "dict_set": {"docs": "<strong>Documentation for dict_set</strong><p>Sets the value associated with key_len-bit key index in dictionary dict to value (a slice), and returns the resulting dictionary.\n</p>"}, "dict_set_ref": {"docs": "<strong>Documentation for dict_set_ref</strong><p>Similar to dict_set, but with the value set to a reference to cell value.\n</p>"}, "dict_get?": {"docs": "<strong>Documentation for dict_get?</strong><p>Looks up key index in dictionary dict with ket_len-bit keys. On success, returns the value found as a slice along with a -1 flag indicating success. On failure, returns (null, 0).\n</p>"}, "dict_get_ref?": {"docs": "<strong>Documentation for dict_get_ref?</strong><p>Similar to dict_get?, but returns the first reference of the found value.\n</p>"}, "dict_get_ref": {"docs": "<strong>Documentation for dict_get_ref</strong><p>A variant of dict_get_ref? that returns null instead of the value if the key index is absent from dictionary dict.\n</p>"}, "dict_set_get_ref": {"docs": "<strong>Documentation for dict_set_get_ref</strong><p>Sets the value associated with index to value (if value is null, then the key is deleted instead) and returns the old value (or null, if the value was absent).\n</p>"}, "dict_delete?": {"docs": "<strong>Documentation for dict_delete?</strong><p>Deletes key_len-bit key index from dictionary dict. If the key is present, returns the modified dictionary dict' and the success flag \u0432\u20ac\u20191. Otherwise, returns the original dictionary dict and 0.\n</p>"}, "dict_delete_get?": {"docs": "<strong>Documentation for dict_delete_get?</strong><p>Deletes ket_len-bit key index from dictionary dict. If the key is present, returns the modified dictionary dict', the original value x associated with the key k (represented by a Slice), and the success flag \u0432\u20ac\u20191. Otherwise, returns (dict, null, 0).\n</p>"}, "dict_add?": {"docs": "<strong>Documentation for dict_add?</strong><p>An add counterpart of dict_set: sets the value associated with key index in dictionary dict to value, but only if it is not already present in D. Returns either modified version of the dictionary and -1 flag or (dict, 0).\n</p>"}, "dict_replace?": {"docs": "<strong>Documentation for dict_replace?</strong><p>A replace operation, which is similar to dict_set, but sets the value of key index in dictionary dict to value only if the key was already present in dict. Returns either modified version of the dictionary and -1 flag or (dict, 0).\n</p>"}, "dict_set_builder": {"docs": "<strong>Documentation for dict_set_builder</strong><p>Similar to dict_set but accept a builder.\n</p>"}, "dict_add_builder?": {"docs": "<strong>Documentation for dict_add_builder?</strong><p>Similar to dict_add?, but accept a builder.\n</p>"}, "dict_replace_builder?": {"docs": "<strong>Documentation for dict_replace_builder?</strong><p>Similar to dict_replace?, but accept a builder.\n</p>"}, "dict_delete_get_min": {"docs": "<strong>Documentation for dict_delete_get_min</strong><p>Computes the minimal key k in the dictionary dict, removes it and returns (dict', x, k, -1), where dict' is the modified version of dict and x is the value associated with k. If the dict is empty, returns (dict, null, null, 0).<p>Note that the key returned by idict_delete_get_min may differ from the key returned by dict_delete_get_min and udict_delete_get_min.</p>\n</p>"}, "dict_delete_get_max": {"docs": "<strong>Documentation for dict_delete_get_max</strong><p>Computes the maximal key k in the dictionary dict, removes it and returns (dict', x, k, -1), where dict' is the modified version of dict and x is the value associated with k. If the dict is empty, returns (dict, null, null, 0).\n</p>"}, "dict_get_min?": {"docs": "<strong>Documentation for dict_get_min?</strong><p>Computes the minimal key k in dictionary dict, the associated value x and returns (k, x, -1). If the dictionary is empty, returns (null, null, 0).\n</p>"}, "dict_get_max?": {"docs": "<strong>Documentation for dict_get_max?</strong><p>Computes the maximal key k in dictionary dict, the associated value x and returns (k, x, -1). If the dictionary is empty, returns (null, null, 0).\n</p>"}, "dict_get_min_ref?": {"docs": "<strong>Documentation for dict_get_min_ref?</strong><p>Similar to dict_get_min?, but returns the only reference in the value as a reference.\n</p>"}, "dict_get_max_ref?": {"docs": "<strong>Documentation for dict_get_max_ref?</strong><p>Similar to dict_get_max?, but returns the only reference in the value as a reference.\n</p>"}, "dict_get_next?": {"docs": "<strong>Documentation for dict_get_next?</strong><p>Computes the minimal key k in dictionary dict that is greater than pivot, and returns k, associated value and a flag indicating success. If the dictionary is empty, returns (null, null, 0).\n</p>"}, "dict_get_nexteq?": {"docs": "<strong>Documentation for dict_get_nexteq?</strong><p>Similar to dict_get_next?, but computes the minimal key k that is greater than or equal to pivot.\n</p>"}, "dict_get_prev?": {"docs": "<strong>Documentation for dict_get_prev?</strong><p>Similar to dict_get_next?, but computes the maximal key k smaller than pivot.\n</p>"}, "dict_get_preveq?": {"docs": "<strong>Documentation for dict_get_preveq?</strong><p>Similar to dict_get_prev?, but computes the maximal key k smaller than or equal to pivot.\n</p>"}, "new_dict": {"docs": "<strong>Documentation for new_dict</strong><p>Creates an empty dictionary, which is actually a null value. Special case of null().\n</p>"}, "dict_empty?": {"docs": "<strong>Documentation for dict_empty?</strong><p>Checks whether a dictionary is empty. Equivalent to cell_null?.\n</p>"}, "pfxdict_get?": {"docs": "<strong>Documentation for pfxdict_get?</strong><p>Returns (s', x, s'', -1) or (null, null, s, 0). Looks up the unique prefix of slice key present in the prefix code dictionary dict. If found, the prefix of s is returned as s', and the corresponding value (also a slice) as x. The remainder of s is returned as a slice s''. If no prefix of s is a key in prefix code dictionary dict, returns the unchanged s and a zero flag to indicate failure.\n</p>"}, "pfxdict_set?": {"docs": "<strong>Documentation for pfxdict_set?</strong><p>Similar to dict_set, but may fail if the key is a prefix of another key presented in the dictionary. Returns flag, indicating success.\n</p>"}, "pfxdict_delete?": {"docs": "<strong>Documentation for pfxdict_delete?</strong><p>Similar to dict_delete?.\n</p>"}, "null": {"docs": "<strong>Documentation for null</strong><p>By the TVM type Null FunC represents absence of a value of some atomic type. So null can actually have any atomic type.\n</p>"}, "~impure_touch": {"docs": "<strong>Documentation for ~impure_touch</strong><p>Mark a variable as used, such that the code which produced it won't be deleted even it is not impure. (c.f. impure specifier)\n</p>"}, "min": {"docs": "<strong>Documentation for min</strong><p>Computes the minimum of two integers x and y.\n</p>"}, "max": {"docs": "<strong>Documentation for max</strong><p>Computes the maximum of two integers x and y.\n</p>"}, "minmax": {"docs": "<strong>Documentation for minmax</strong><p>Sorts two integers.\n</p>"}, "ab": {"docs": "<strong>Documentation for ab</strong><p>Computes the absolute value of an integer x.</p>"}
}